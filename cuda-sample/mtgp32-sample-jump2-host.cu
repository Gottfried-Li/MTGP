/**
 * Sample host program for near jump (2<sup>256</sup> steps jump ahead)
 */
#include <stdio.h>
#include <errno.h>
#include <string>
//#include <NTL/GF2X.h>
//#include "mtgp32-calc-poly.hpp"
//#include "mtgp-calc-jump.hpp"
#include "mtgp32-quick-fix.hpp"
#include "mtgp-util.cuh"
#include "mtgp32-jump-kernel.cuh"
#include "mtgp32-sample-jump2-kernel.cu"

#if defined(CHECK)
#include "mtgp32-fast-jump.h"
/**
 *
 */
using namespace std;
static mtgp32_fast_t mtgp32;
static int init_check_data(uint32_t seed)
{
    int rc = mtgp32_init(&mtgp32,
			 &mtgp32_params_fast_11213[0],
			 seed);
    if (rc) {
	return rc;
    }
    return 0;
}

static int init_check_data_array(uint32_t seed_array[], int size)
{
    int rc = mtgp32_init_by_array(&mtgp32,
				  &mtgp32_params_fast_11213[0],
				  seed_array,
				  size);
    if (rc) {
	return rc;
    }
    return 0;
}

static void free_check_data()
{
    mtgp32_free(&mtgp32);
}

static void check_data(uint32_t * h_data, int num_data)
{
    for (int i = 0; i < num_data; i++) {
	uint32_t r = mtgp32_genrand_uint32(&mtgp32);
	if (h_data[i] != r) {
	    printf("mismatch i = %d, data = %u, r = %u\n",
		   i, h_data[i], r);
	    printf("check N.G!\n");
	    return;
	}
    }
    printf("check O.K!\n");
}
#endif	/* defined(CHECK) */

/**
 * make jump polynomials in device constant memory
 * @param[in] block_num number of cuda kernel blocks
 * @param[in] small_data_num number of data generated by one kernel call
 */
static void make_jump_polynomial(int block_num, int small_data_num)
{
    const int tbl_size = 6;
    long large_jump_step = small_data_num + small_data_num / block_num;
    int gen_tbl[tbl_size] = {1, 4, 16, 64, 256, 1024};
    string poly;
    int status_size = sizeof(uint32_t) * mtgp32.status->size;
    uint32_t * h_large_jump_array = (uint32_t *)malloc(status_size);
    if (h_large_jump_array == NULL) {
	throw "malloc error";
    }
    qf_calc_characteristic(poly, &mtgp32);
    qf_calc_jump(h_large_jump_array,
		 mtgp32.status->size,
		 large_jump_step,
		 poly);
    ccudaMemcpyToSymbol(mtgp32_sample_jump2, h_large_jump_array, status_size);
    free(h_large_jump_array);
    uint32_t * h_small_jump_array = (uint32_t *)malloc(tbl_size * status_size);
    if (h_small_jump_array == NULL) {
	throw "malloc error2";
    }
    for (int i = 0; i < tbl_size; i++) {
	long step = small_data_num * gen_tbl[i];
	qf_calc_jump(h_small_jump_array + i * mtgp32.status->size,
		     mtgp32.status->size,
		     step,
		     poly);
    }
    ccudaMemcpyToSymbol(mtgp32_sample_jump2, h_large_jump_array, status_size);
    free(h_large_jump_array);
}

/**
 * host function.
 * This function calls initialization kernel function.
 *
 * @param[in] d_status kernel I/O data.
 * @param[in] num_data number of data to be generated.
 */
static void initialize_mtgp_kernel(mtgp32_kernel_status_t* d_status,
				   uint32_t seed,
				   int block_num)
{
    struct mtgp32_kernel_status_t* h_status;
    cudaError_t e;
    float gputime;
    cudaEvent_t start;
    cudaEvent_t end;

    printf("initializing and jumping mtgp32 kernel data.\n");
    h_status = (struct mtgp32_kernel_status_t *)
	malloc(sizeof(mtgp32_kernel_status_t) * block_num);
    if (h_status == NULL) {
	printf("failure in allocating host memory for kernel status.\n");
	exit(1);
    }
    ccudaEventCreate(&start);
    ccudaEventCreate(&end);

    ccudaEventRecord(start, 0);
    if (cudaGetLastError() != cudaSuccess) {
	printf("error has been occured before kernel call.\n");
	exit(1);
    }

    /* kernel call
     * CAUTION: the number of threads should be MTGP32_N for
     * initialization.
     */
    mtgp32_jump_seed_kernel<<<block_num, MTGP32_N>>>(d_status,
						     mtgp32_sample_jump2_table,
						     seed);
    cudaThreadSynchronize();

    e = cudaGetLastError();
    if (e != cudaSuccess) {
	printf("failure in kernel call.\n%s\n", cudaGetErrorString(e));
	exit(1);
    }
    ccudaEventRecord(end, 0);
    ccudaEventSynchronize(end);
    ccudaEventElapsedTime(&gputime, start, end);
    printf("Initialization time: %f (ms)\n", gputime);
    ccudaMemcpy(h_status, d_status,
		sizeof(mtgp32_kernel_status_t) * block_num,
		cudaMemcpyDeviceToHost);
//    check_status(h_status, block_num);
    ccudaEventDestroy(start);
    ccudaEventDestroy(end);
}

/**
 * host function.
 * This function calls initialization kernel function.
 *
 * @param[in] d_status kernel I/O data.
 * @param[in] num_data number of data to be generated.
 */
static void initialize_mtgp_array_kernel(mtgp32_kernel_status_t* d_status,
					 uint32_t seed_array[],
					 int seed_size,
					 int block_num)
{
    struct mtgp32_kernel_status_t* h_status;
    uint32_t *h_seed_array;
    uint32_t *d_seed_array;
    cudaError_t e;
    float gputime;
    cudaEvent_t start;
    cudaEvent_t end;

    printf("initializing and jumping mtgp32 kernel data.\n");
    h_status = (struct mtgp32_kernel_status_t *)
	malloc(sizeof(mtgp32_kernel_status_t) * block_num);
    if (h_status == NULL) {
	printf("failure in allocating host memory for kernel status.\n");
	exit(1);
    }
    h_seed_array = (uint32_t *) malloc(sizeof(uint32_t) * seed_size);
    if (h_seed_array == NULL) {
	printf("failure in allocating host memory for seed array.\n");
	exit(1);
    }
    for (int i = 0; i < seed_size; i++) {
	h_seed_array[i] = seed_array[i];
    }
    ccudaMalloc((void**)&d_seed_array, sizeof(uint32_t) * seed_size);
    ccudaMemcpy(d_seed_array, h_seed_array,
		sizeof(uint32_t) * seed_size,
		cudaMemcpyHostToDevice);
    ccudaEventCreate(&start);
    ccudaEventCreate(&end);

    ccudaEventRecord(start, 0);
    if (cudaGetLastError() != cudaSuccess) {
	printf("error has been occured before kernel call.\n");
	exit(1);
    }

    /* kernel call
     * CAUTION: the number of threads should be MTGP32_N for
     * initialization.
     */
    mtgp32_jump_array_kernel<<<block_num, MTGP32_N>>>(
	d_status,
	mtgp32_sample_jump2_table,
	d_seed_array,
	seed_size);
    cudaThreadSynchronize();

    e = cudaGetLastError();
    if (e != cudaSuccess) {
	printf("failure in kernel call.\n%s\n", cudaGetErrorString(e));
	exit(1);
    }
    ccudaEventRecord(end, 0);
    ccudaEventSynchronize(end);
    ccudaEventElapsedTime(&gputime, start, end);
    printf("Initialization time (seed array): %f (ms)\n", gputime);
    ccudaMemcpy(h_status, d_status,
		sizeof(mtgp32_kernel_status_t) * block_num,
		cudaMemcpyDeviceToHost);
    //check_status(h_status, block_num);
    ccudaEventDestroy(start);
    ccudaEventDestroy(end);
    ccudaFree(d_seed_array);
    free(h_seed_array);
}

/**
 * host function.
 * This function calls corresponding kernel function.
 *
 * @param[in] d_status kernel I/O data.
 * @param[in] num_data number of data to be generated.
 */
static void make_uint32_random(mtgp32_kernel_status_t* d_status,
			       int num_data,
			       int block_num) {
    uint32_t* d_data;
    uint32_t* h_data;
    cudaError_t e;
    float gputime;
    cudaEvent_t start;
    cudaEvent_t end;

    printf("generating 32-bit unsigned random numbers.\n");
    ccudaMalloc((void**)&d_data, sizeof(uint32_t) * num_data);
    /* cutCreateTimer(&timer); */
    ccudaEventCreate(&start);
    ccudaEventCreate(&end);

    h_data = (uint32_t *) malloc(sizeof(uint32_t) * num_data);
    if (h_data == NULL) {
	printf("failure in allocating host memory for output data.\n");
	exit(1);
    }
    /* cutStartTimer(timer); */
    ccudaEventRecord(start, 0);
    if (cudaGetLastError() != cudaSuccess) {
	printf("error has been occured before kernel call.\n");
	exit(1);
    }

    /* kernel call */
    mtgp32_uint32_kernel<<<block_num, MTGP32_TN>>>(
	d_status, d_data, num_data / block_num);
    cudaThreadSynchronize();

    e = cudaGetLastError();
    if (e != cudaSuccess) {
	printf("failure in kernel call.\n%s\n", cudaGetErrorString(e));
	exit(1);
    }
    /* ccutStopTimer(timer); */
    ccudaEventRecord(end, 0);
    ccudaEventSynchronize(end);
    ccudaMemcpy(h_data, d_data,
		sizeof(uint32_t) * num_data, cudaMemcpyDeviceToHost);
    /* gputime = cutGetTimerValue(timer); */
    ccudaEventElapsedTime(&gputime, start, end);
#if defined(CHECK)
    check_data(h_data, num_data);
#endif
    print_uint32_array(h_data, num_data, block_num);
    printf("generated numbers: %d\n", num_data);
    printf("Processing time: %f (ms)\n", gputime);
    printf("Samples per second: %E \n", num_data / (gputime * 0.001));

    /* ccutDeleteTimer(timer); */
    ccudaEventDestroy(start);
    ccudaEventDestroy(end);
    //free memories
    free(h_data);
    ccudaFree(d_data);
}

/**
 * host function.
 * This function calls corresponding kernel function.
 *
 * @param[in] d_status kernel I/O data.
 * @param[in] num_data number of data to be generated.
 */
static void jump_random(mtgp32_kernel_status_t* d_status, int block_num) {
    cudaError_t e;
    float gputime;
    cudaEvent_t start;
    cudaEvent_t end;

    printf("jumping.\n");
    /* cutCreateTimer(&timer); */
    ccudaEventCreate(&start);
    ccudaEventCreate(&end);

    /* cutStartTimer(timer); */
    ccudaEventRecord(start, 0);
    if (cudaGetLastError() != cudaSuccess) {
	printf("error has been occured before kernel call.\n");
	exit(1);
    }

    /* kernel call */
    mtgp32_jump_kernel<<<block_num, MTGP32_TN>>>(d_status,
						 mtgp32_sample_jump2,
						 1);
    cudaThreadSynchronize();

    e = cudaGetLastError();
    if (e != cudaSuccess) {
	printf("failure in kernel call.\n%s\n", cudaGetErrorString(e));
	exit(1);
    }
    /* ccutStopTimer(timer); */
    ccudaEventRecord(end, 0);
    ccudaEventSynchronize(end);
    /* gputime = cutGetTimerValue(timer); */
    ccudaEventElapsedTime(&gputime, start, end);
    printf("jumping time: %f (ms)\n", gputime);

    /* ccutDeleteTimer(timer); */
    ccudaEventDestroy(start);
    ccudaEventDestroy(end);
}

int main(int argc, char** argv)
{
    // LARGE_SIZE is a multiple of 16
    int num_data = 0;
    int block_num;
    int num_unit;
    int r;
    int device = 0;
    mtgp32_kernel_status_t *d_status;

    ccudaSetDevice(device);
    int count = 4;

    if (argc >= 2) {
	errno = 0;
	block_num = strtol(argv[1], NULL, 10);
	if (errno) {
	    printf("%s number_of_block number_of_output\n", argv[0]);
	    return 1;
	}
	if (block_num < 1) {
	    printf("%s block_num should be greater than 1\n", argv[0]);
	    return 1;
	}
	errno = 0;
	num_data = strtol(argv[2], NULL, 10);
	if (errno) {
	    printf("%s number_of_block number_of_output\n", argv[0]);
	    return 1;
	}
	argc -= 2;
	argv += 2;
    } else {
	printf("%s number_of_block number_of_output\n", argv[0]);
	return 1;
    }
    num_unit = MTGP32_LS * block_num;
    ccudaMalloc((void**)&d_status,
			      sizeof(mtgp32_kernel_status_t) * block_num);
    r = num_data % num_unit;
    if (r != 0) {
	num_data = num_data + num_unit - r;
    }
    uint32_t seed = 1;
    uint32_t rc = 0;
    rc = init_check_data(seed);
    if (rc != 0) {
	printf("init check data ERROR\n");
	return 1;
    }
    initialize_mtgp_kernel(d_status, seed, block_num);
    for (int i = 0; i < count; i++) {
	make_uint32_random(d_status, num_data, block_num);
	jump_random(d_status, block_num);
    }
    //make_single_random(d_status, num_data, block_num);
    free_check_data();

    // another initialization
    uint32_t seed_array[] = {1,2,3,4,5,6,7};
    rc = init_check_data_array(seed_array, 7);
    if (rc != 0) {
	printf("init check data array ERROR\n");
	return 1;
    }
    initialize_mtgp_array_kernel(d_status, seed_array, 7, block_num);
    for (int i = 0; i < count; i++) {
	make_uint32_random(d_status, num_data, block_num);
	jump_random(d_status, block_num);
    }
    free_check_data();
    ccudaFree(d_status);
    return 0;
}





